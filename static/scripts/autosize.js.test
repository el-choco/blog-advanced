/*!
  Autosize 4.0.0 (angepasst)
  license: MIT
  Original: http://www.jacklmoore.com/autosize
  Änderungen:
  - Respektiere vorhandenes CSS-Resize (kein erzwungenes 'none' oder 'horizontal')
  - Inline-Styles minimal halten (kein hartes Setzen von overflowX/wordWrap)
  - OverflowY-Handling defensiver (nur wenn nötig)
*/

(function (global, factory) {
  if (typeof define === 'function' && define.amd) {
    define(['exports', 'module'], factory);
  } else if (typeof exports !== 'undefined' && typeof module !== 'undefined') {
    factory(exports, module);
  } else {
    var mod = { exports: {} };
    factory(mod.exports, mod);
    global.autosize = mod.exports;
  }
})(this, function (exports, module) {
  'use strict';

  var map = typeof Map === 'function'
    ? new Map()
    : (function () {
        var keys = [];
        var values = [];
        return {
          has: function (key) { return keys.indexOf(key) > -1; },
          get: function (key) { return values[keys.indexOf(key)]; },
          set: function (key, value) {
            if (keys.indexOf(key) === -1) {
              keys.push(key);
              values.push(value);
            }
          },
          'delete': function (key) {
            var index = keys.indexOf(key);
            if (index > -1) {
              keys.splice(index, 1);
              values.splice(index, 1);
            }
          }
        };
      })();

  var createEvent = function (name) {
    return new Event(name, { bubbles: true });
  };
  try {
    new Event('test');
  } catch (e) {
    createEvent = function (name) {
      var evt = document.createEvent('Event');
      evt.initEvent(name, true, false);
      return evt;
    };
  }

  function assign(ta) {
    if (!ta || !ta.nodeName || ta.nodeName !== 'TEXTAREA' || map.has(ta)) return;

    var heightOffset = 0;
    var clientWidth = ta.clientWidth;
    var cachedHeight = null;

    function init() {
      var style = window.getComputedStyle(ta, null);

      // RESPEKT: Erzwinge kein Resize-Verhalten, respektiere vorhandenes CSS.
      // Original: setzt 'none' oder 'horizontal' – entfernt.

      // Höhe-Korrektur abhängig von Box-Modell
      if (style.boxSizing === 'content-box') {
        heightOffset = -(parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
      } else {
        heightOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
      }
      if (isNaN(heightOffset)) heightOffset = 0;

      update();
    }

    function getParentOverflows(el) {
      var arr = [];
      while (el && el.parentNode && el.parentNode instanceof Element) {
        if (el.parentNode.scrollTop) {
          arr.push({ node: el.parentNode, scrollTop: el.parentNode.scrollTop });
        }
        el = el.parentNode;
      }
      return arr;
    }

    function setOverflowY(value) {
      // Defensive: nur setzen, wenn wirklich nötig
      var current = ta.style.overflowY;
      if (current !== value) {
        // Chrome/Safari Reflow-Trick nur ausführen, wenn wir tatsächlich ändern
        var width = ta.style.width;
        ta.style.width = '0px';
        ta.offsetWidth; // force reflow
        ta.style.width = width;
        ta.style.overflowY = value;
      }
    }

    function resize() {
      var originalHeight = ta.style.height;
      var overflows = getParentOverflows(ta);
      var docTop = document.documentElement && document.documentElement.scrollTop;

      // Temporär Höhe freigeben
      ta.style.height = '';

      // Wenn element hidden/detached ist (scrollHeight=0), alte Höhe beibehalten
      var scrollH = ta.scrollHeight;
      if (!scrollH || scrollH === 0) {
        ta.style.height = originalHeight;
        return;
      }

      var endHeight = scrollH + heightOffset;
      if (endHeight < 0) endHeight = 0;

      ta.style.height = endHeight + 'px';
      clientWidth = ta.clientWidth;

      // Scroll-Positionen der Eltern wiederherstellen
      overflows.forEach(function (el) { el.node.scrollTop = el.scrollTop; });
      if (docTop) document.documentElement.scrollTop = docTop;
    }

    function update() {
      resize();

      var styleHeight = Math.round(parseFloat(ta.style.height) || 0);
      var computed = window.getComputedStyle(ta, null);

      // Ersatz für computed.height bei border-box
      var actualHeight = computed.boxSizing === 'content-box'
        ? Math.round(parseFloat(computed.height) || 0)
        : ta.offsetHeight;

      if (styleHeight <= 0 && actualHeight > 0) {
        // Fallback: wenn style.height leer ist, aber tatsächliche Höhe existiert,
        // setze height entsprechend
        ta.style.height = actualHeight + 'px';
      }

      // Overflow-Management: nur wenn nötig umschalten
      // Wenn tatsächliche Höhe != styleHeight, wurde max-height überschritten
      if (actualHeight !== styleHeight) {
        if (computed.overflowY === 'hidden') {
          setOverflowY('auto'); // statt 'scroll' – vermeiden erzwungenen Scrollbar
          resize();
          actualHeight = computed.boxSizing === 'content-box'
            ? Math.round(parseFloat(window.getComputedStyle(ta, null).height) || 0)
            : ta.offsetHeight;
        }
      } else {
        // Normalsituation: Overflow ohne Scrollbar
        if (computed.overflowY !== 'hidden') {
          setOverflowY('hidden');
          resize();
          actualHeight = computed.boxSizing === 'content-box'
            ? Math.round(parseFloat(window.getComputedStyle(ta, null).height) || 0)
            : ta.offsetHeight;
        }
      }

      if (cachedHeight !== actualHeight) {
        cachedHeight = actualHeight;
        var evt = createEvent('autosize:resized');
        try {
          ta.dispatchEvent(evt);
        } catch (err) {
          // Detached Element in Firefox – ignorieren
        }
      }
    }

    var pageResize = function () {
      if (ta.clientWidth !== clientWidth) {
        update();
      }
    };

    var destroy = (function (style) {
      window.removeEventListener('resize', pageResize, false);
      ta.removeEventListener('input', update, false);
      ta.removeEventListener('keyup', update, false);
      ta.removeEventListener('autosize:destroy', destroy, false);
      ta.removeEventListener('autosize:update', update, false);

      // Ursprungs-Styles wiederherstellen
      Object.keys(style).forEach(function (key) {
        ta.style[key] = style[key];
      });

      map['delete'](ta);
    }).bind(ta, {
      height: ta.style.height,
      resize: ta.style.resize,
      overflowY: ta.style.overflowY,
      overflowX: ta.style.overflowX,
      wordWrap: ta.style.wordWrap
    });

    ta.addEventListener('autosize:destroy', destroy, false);

    // IE9: keyup-Fallback
    if ('onpropertychange' in ta && 'oninput' in ta) {
      ta.addEventListener('keyup', update, false);
    }

    window.addEventListener('resize', pageResize, false);
    ta.addEventListener('input', update, false);
    ta.addEventListener('autosize:update', update, false);

    // RESPEKT: Keine harten Defaults für overflowX/wordWrap setzen.
    // Original setzte: ta.style.overflowX = 'hidden'; ta.style.wordWrap = 'break-word';
    // Entfernt, um Theme-/CSS-Regeln nicht zu übersteuern.

    map.set(ta, { destroy: destroy, update: update });
    init();
  }

  function destroy(ta) {
    var methods = map.get(ta);
    if (methods) methods.destroy();
  }

  function update(ta) {
    var methods = map.get(ta);
    if (methods) methods.update();
  }

  var autosize = null;

  // Nicht in Node/IE8
  if (typeof window === 'undefined' || typeof window.getComputedStyle !== 'function') {
    autosize = function (el) { return el; };
    autosize.destroy = function (el) { return el; };
    autosize.update = function (el) { return el; };
  } else {
    autosize = function (el) {
      if (el) {
        Array.prototype.forEach.call(el.length ? el : [el], function (x) { return assign(x); });
      }
      return el;
    };
    autosize.destroy = function (el) {
      if (el) {
        Array.prototype.forEach.call(el.length ? el : [el], destroy);
      }
      return el;
    };
    autosize.update = function (el) {
      if (el) {
        Array.prototype.forEach.call(el.length ? el : [el], update);
      }
      return el;
    };
  }

  module.exports = autosize;
});